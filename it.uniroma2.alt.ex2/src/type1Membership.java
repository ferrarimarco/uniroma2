import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;

/**
 *
 * This class tests if a word can be generated by a type1 grammar, both given in
 * input by the user, at run time.<br \>
 * See <a href="http://java.sun.com/j2se/javadoc/writingdoccomments/">How To
 * Write Javadoc Comments</a> for additional details about the Javadoc of this
 * project.
 *
 * @author Marco Ferrari
 */
public class type1Membership {

	private ArrayList<String> rhsNoOr;
	private ArrayList<Integer> matchesKMP;
	private String readString;
	private String lhsSearch;
	private String rhsSearch;
	private ArrayList<String>[] formattedGrammar;
	private int counterFormatter;
	private ArrayList<String> productionsFormatter;
	private String s;
	private int lhsLenght;
	private String lhs;
	private ArrayList<Integer> indiciOR;
	private ArrayList<Integer> kmpResult;
	private String foldedString;
	private int[] p;

	public static void main(String[] args) {

		type1Membership a = new type1Membership();

		System.out.print("Inserire la grammatica: ");
		String consoleGrammar = a.consoleReader();

		System.out.print("Inserire la parola: ");
		String consoleWord = a.consoleReader();

		ArrayList<String>[] consoleGrammarFormatted = a.grammarFormatter(consoleGrammar);
		a.grammarPrinter(consoleGrammarFormatted);

		System.out.println();

		// Controllo se i terminali della parola sono contenuti in Vt
		boolean terminalsChecker = true;

		for (int i = 0; i < consoleWord.length(); i++) {
			if (consoleGrammarFormatted[0].contains(consoleWord.substring(i, i + 1)) == false) {
				terminalsChecker = false;
			}
		}

		if (terminalsChecker == true) {

			// ArrayList per memorizzare le occorenze del pattern in word,
			// utilizzando KMP
			boolean membershipResult = a.membershipChecker(consoleWord, consoleGrammarFormatted);

			if (membershipResult == true) {
				System.out.println("La parola appartiene al linguaggio");
			} else {
				System.out.println("La parola non appartiene al linguaggio");
			}
		} else {
			System.out.println("La parola non appartiene al linguaggio");
		}
	}

	/**
	 * Reads a string input from the console, using InputStreamReader and
	 * BufferedReader
	 *
	 * @return readString the string read from the console
	 *
	 */
	private String consoleReader() {

		readString = "";

		InputStreamReader inputStreamReader = new InputStreamReader(System.in);

		BufferedReader bufferedReader = new BufferedReader(inputStreamReader);

		try {
			readString = bufferedReader.readLine();
		} catch (IOException e) {
			System.out.println("Errore nell'input da console: " + e);
		}

		return readString;

	}

	/**
	 * Returns the LHS of a given production
	 *
	 * @param String
	 *            production - production to search into
	 * @param char
	 *            separator - LHS-RHS separator
	 * @return rhsSearch - LHS of the given production
	 */
	private String lhsSearch(String production, char separator) {
		lhsSearch = production.substring(0, production.indexOf(separator));
		return lhsSearch;
	}

	/**
	 * Returns the RHS of a given production
	 *
	 * @param String
	 *            production - production to search into
	 * @param char
	 *            separator - LHS-RHS separator
	 * @return rhsSearch - RHS of the given production
	 */
	private String rhsSearch(String production, char separator) {
		rhsSearch = production.substring(production.indexOf(separator) + 1);
		return rhsSearch;
	}

	/**
	 * Prints given grammar on the default console
	 *
	 * @param ArrayList
	 *            <String>[] grammar - Given grammar
	 */
	public void grammarPrinter(ArrayList<String>[] grammar) {
		String nomeInsieme = "";

		for (int i = 0; i < grammar.length; i++) {
			switch (i) {
				case 0:
					nomeInsieme = "Insieme dei terminali (Vt)";
					break;
				case 1:
					nomeInsieme = "Insieme dei non terminali (Vn)";
					break;
				case 2:
					nomeInsieme = "Insieme delle produzioni (P)";
					break;
				case 3:
					nomeInsieme = "Assioma (S)";
					break;
			}

			System.out.print(nomeInsieme + " = {");

			for (int j = 0; j < grammar[i].size(); j++) {
				System.out.print("{" + grammar[i].get(j) + "}");
				if (j != grammar[i].size() - 1) {
					System.out.print(",");
				}
			}

			System.out.print("}");
			System.out.println();
		}
	}

	/**
	 * Inizializes an Array of ArrayLists (String)
	 *
	 * @param ArrayList
	 *            <String>[] arrayList - The array to be inizialised
	 */
	private void ArrayListInit(ArrayList<String>[] arrayList) {

		for (int i = 0; i < arrayList.length; i++) {
			arrayList[i] = new ArrayList<String>();
		}

	}

	/**
	 * Converts any given string as standard form grammar. It consists in an
	 * Array of four ArrayLists, representing the 4-tule <Vt, Vn, P, S>.
	 *
	 * @param String
	 *            grammarString - String to be converted in the standard form
	 * @return formattedGrammar - An Array of four ArrayLists
	 *
	 */
	@SuppressWarnings("unchecked")
	public ArrayList<String>[] grammarFormatter(String grammarString) {

		// Inizializzo gli ArrayList di formattedGrammar
		formattedGrammar = new ArrayList[4];
		ArrayListInit(formattedGrammar);

		// Primo elemento della stringa = assioma; lo aggiungo
		formattedGrammar[3].add(lhsSearch(grammarString, '-'));

		// Costruisco gli insiemi Vt e Vn
		for (int i = 0; i < grammarString.length(); i++) {

			// Esamino la stringa e aggiungo elementi a Vt e Vn, escludendo i
			// simboli - > ; . e
			if ((grammarString.charAt(i) != '|') && (grammarString.charAt(i) != 'e') && (grammarString.charAt(i) != '-') && (grammarString.charAt(i) != '>') && (grammarString.charAt(i) != ';') && (grammarString.charAt(i) != '.')) {

				// Controllo se carattere maiuscolo o minuscolo e lo inserisco
				// nell'insieme oppurtuno
				if (Character.isLowerCase(grammarString.charAt(i)) && (formattedGrammar[0].contains(Character.toString(grammarString.charAt(i))) == false)) {
					// minuscolo = aggiungo a terminali

					// Controllo se l'elemento è già presente nell'insieme
					formattedGrammar[0].add(Character.toString(grammarString.charAt(i)));

				} else if (Character.isUpperCase(grammarString.charAt(i)) && (formattedGrammar[1].contains(Character.toString(grammarString.charAt(i))) == false)) {

					// maiuscolo = aggiungo a non terminali
					formattedGrammar[1].add(Character.toString(grammarString.charAt(i)));
				}
			}
		}

		// Costruisco l'insieme delle produzioni

		// Inizializzo il contatore
		counterFormatter = 0;

		// ArrayList per formattare le produzioni
		productionsFormatter = new ArrayList<String>();

		// Divido la stringa in più parti (ES: se c'è un Or inserisco due
		// produzioni con lo stesso lhs)
		while ((grammarString.length() != 0) && (counterFormatter < grammarString.length())) {

			// Cerco un delimitatore nella stringa (; o .)
			if ((grammarString.charAt(counterFormatter) == ';') || (grammarString.charAt(counterFormatter) == '.')) {
				// Se ho trovato un delimitatore...

				// Sottostringa da analizzare
				s = grammarString.substring(0, counterFormatter);

				// Aggiorno la stringa in input (tolgo la sottostringa che sto
				// elaborando ora)
				grammarString = grammarString.substring(counterFormatter + 1);

				// Memorizzo il lhs in una variabile e lo tolgo dalla
				// sottostringa che sto analizzando
				lhsLenght = s.indexOf('-');
				lhs = s.substring(0, lhsLenght);
				s = s.substring(lhsLenght + 2);

				// Controllo per l'or
				boolean checkerOR = false;

				// Cerco gli eventuali or nella stringa che sto analizzando
				for (int i = 0; i < s.length(); i++) {
					if (s.charAt(i) == '|') {
						// Ho trovato almeno un or
						checkerOR = true;

						// Esco dal for se trovo un or
						break;
					}
				}

				if (checkerOR == false) {
					// Se non ci sono or...
					// Aggiungo la produzione all'insieme delle produzioni:
					// LHS + rhs
					productionsFormatter.add(lhs + ";" + s);

				} else {
					// Se ho trovato gli or...
					// Memorizzo gli indici degli or
					indiciOR = new ArrayList<Integer>();

					for (int i = 0; i < s.length(); i++) {
						if (s.charAt(i) == '|') {
							indiciOR.add(i);
						}
					}

					// Memorizzo il rhs, diviso in corrispondenza degli or
					rhsNoOr = new ArrayList<String>();

					if (indiciOR.size() == 1) {
						// Caso 1: un solo OR
						rhsNoOr.add(s.substring(0, indiciOR.get(0)));
						rhsNoOr.add(s.substring(indiciOR.get(0) + 1));
					} else {
						for (int i = 0; i < indiciOR.size(); i++) {
							if (i == 0) {
								// Primo OR
								rhsNoOr.add(s.substring(0, indiciOR.get(i)));
							} else if (i == indiciOR.size() - 1) {
								// Ultimo OR

								// Aggiungo prima parte
								rhsNoOr.add(s.substring(indiciOR.get(i - 1) + 1, indiciOR.get(i)));

								// Aggiungo seconda parte
								rhsNoOr.add(s.substring(indiciOR.get(i) + 1));
							} else {
								// Comportamento normale
								rhsNoOr.add(s.substring(indiciOR.get(i - 1) + 1, indiciOR.get(i)));
							}
						}
					}

					// Aggiungo tutte le produzioni spezzate con lo stesso lhs
					// alla lista delle produzioni
					for (int i = 0; i < rhsNoOr.size(); i++) {
						productionsFormatter.add(lhs + ";" + rhsNoOr.get(i));
					}
				}

				// Reinizializzo le variabili di controllo
				counterFormatter = -1;
				checkerOR = false;
			}

			// Incremento il contatore per passare al carattere successivo
			counterFormatter++;
		}

		// Aggiungo la lista delle produzioni alla grammatica formattata
		formattedGrammar[2].addAll(productionsFormatter);

		// Restituisco la grammatica formattata
		return formattedGrammar;
	}

	/**
	 * Returns an ArrayList with all the indexes where pattern occours in word.
	 * This is done using the Knutt-Morris-Pratt algorithm. See <a
	 * href="http://www.iasi.rm.cnr.it/~Eadp/Teach/ALT07/KMPpatternmatcher.pdf">http://www.iasi.rm.cnr.it/%7Eadp/Teach/ALT07/KMPpatternmatcher.pdf</a>
	 * for additional details.
	 *
	 * @param String
	 *            pattern - String to search
	 * @param word -
	 *            String to search into
	 *
	 * @return matchesKMP - ArrayList with the indexes of the matches
	 *
	 */
	private ArrayList<Integer> KMPMatch(String pattern, String word) {

		matchesKMP = new ArrayList();

		if (pattern.length() <= word.length()) {

			p = new int[pattern.length()];
			p[0] = 0;

			int j = 0;

			for (int i = 1; i < pattern.length(); i++) {
				while ((j > 0) && (pattern.charAt(j) != pattern.charAt(i))) {
					j = p[j - 1];
				}
				if (pattern.charAt(j) == pattern.charAt(i)) {
					j++;
				}
				p[i] = j;
			}

			j = 0;

			for (int i = 0; i < word.length(); i++) {
				while ((j > 0) && (pattern.charAt(j) != word.charAt(i))) {
					j = p[j - 1];
				}
				if (pattern.charAt(j) == word.charAt(i)) {
					j++;
				}
				if (j == pattern.length()) {
					matchesKMP.add(i - pattern.length() + 1);
					j = p[j - 1];
				}
			}
		}

		System.out.println(matchesKMP);

		return matchesKMP;
	}

	//S->aabB|aBa;B->bB|C|f;abC->abb|qqC;C->d|S.
	
	/**
	 *
	 * Checks if a word is in the set L(G), where G is a Type1 grammar. In other
	 * words it checks if word can be generated by grammar. It tries to fold the
	 * word (using recursion), according to the production rules of grammar.
	 *
	 * @param String
	 *            word - String check
	 * @param grammar -
	 *            grammar
	 *
	 * @return true - if the word can be generated by grammar
	 *
	 */
	private boolean membershipChecker(String word, ArrayList<String>[] grammar) {

		// Basic case: se la parole è uguale all'assioma return true
		if (word.equals(grammar[3].get(0)) == true) {
			return true;
		}

		// Cerco nella parola il RHS di ciascuna produzione e faccio folding
		// della parola secondo il LHS delle produzioni trovate
		for (int i = 0; i < grammar[2].size(); i++) {

			// ArrayList per memorizzare gli indici dove è il pattern in parola
			// (utilizzando KMP)
			kmpResult = KMPMatch(rhsSearch(grammar[2].get(i), ';'), word);

System.out.println("KMP: " + kmpResult);

			// Faccio tutti i possibili folding
			for (int j = 0; j < kmpResult.size(); j++) {

				// Foldo la stringa
				foldedString = word.substring(0, kmpResult.get(j)) + lhsSearch(grammar[2].get(i), ';') + word.substring(kmpResult.get(j) + rhsSearch(grammar[2].get(i), ';').length());

				// Se la parola foldata è diversa da quella di partenza,
				// continuo a foldare
				if (foldedString.equals(word) == false) {
					if (membershipChecker(foldedString, grammar) == true) {
						return true;
					}
				}
			}
		}
		return false;
	}

	/*
	 * ----- CLASS TESTING -----
	 *
	 * EXAMPLE 1
	 *
	 * consoleGrammar =
	 * "S->AA|SSSSSSSSSSSS;A->AB|BC|CD|DE|DF|DG|AG|HG|EG|AH|AED|AGW|ACF|AWF|AHH|AAA;BC->sadfa|AAA|BEW;DE->faW;AG->fad;AB->ccRA|ASA|AcE|BGE|BSb|BbAA|BaB|aAA|AaAA|AAAB|ABAD|DADAA;AAA->ghhu.";
	 *
	 * consoleWord = "ghhughhu"; //E' generabile dalla grammatica consoleWord =
	 * "sadfaghhughhu"; //E' generabile dalla grammatica consoleWord =
	 * "ababaaaaaaaabababababbbbbababba"; //Non è generabile dalla grammatica
	 *
	 *
	 * EXAMPLE 2
	 *
	 * consoleGrammar = "S->ABc|a;AB->acB;Bc->ab;ac->cBc|bc|cb.";
	 *
	 * consoleWord = "a"; //E' generabile dalla grammatica 
	 * consoleWord = "bcab"; //E' generabile dalla grammatica 
	 * consoleWord = "abab"; //Non è generabile dalla grammatica
	 *
	 */
}
