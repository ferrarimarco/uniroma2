package info.ferrarimarco.uniroma2.msa.resourcesharing.io.gcm;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

import javax.annotation.PostConstruct;
import javax.net.ssl.SSLSocketFactory;
import javax.security.sasl.SaslException;

import org.jivesoftware.smack.ConnectionConfiguration;
import org.jivesoftware.smack.ConnectionConfiguration.SecurityMode;
import org.jivesoftware.smack.SmackException;
import org.jivesoftware.smack.XMPPConnection;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.filter.PacketTypeFilter;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Packet;
import org.jivesoftware.smack.provider.ProviderManager;
import org.jivesoftware.smack.tcp.XMPPTCPConnection;
import org.json.simple.JSONValue;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class GcmMessageSender {
	
	private static Random random;
	
	private XMPPConnection connection;
	
	@Value("${info.ferrarimarco.msa.resourcesharing.gcm.server}")
	private String gcmServer;
	
	@Value("${info.ferrarimarco.msa.resourcesharing.gcm.port}")
	private String gcmServerPort;
	
	@Value("${info.ferrarimarco.msa.resourcesharing.gcm.username}")
	private String username;
	
	@Value("${info.ferrarimarco.msa.resourcesharing.gcm.serverkey}")
	private String password;
	
	public void connect() throws SmackException, IOException, XMPPException {
		connection.connect();
	}
	
	public void login() throws SaslException, XMPPException, SmackException, IOException {
		connection.login(username, password);
	}
	
	@PostConstruct
	public void initConnection() throws XMPPException, SmackException, IOException {
		// Add GcmPacketExtension
		ProviderManager.addExtensionProvider(GcmPacketExtension.GCM_ELEMENT_NAME, GcmPacketExtension.GCM_NAMESPACE, new GcmPacketExtensionProvider());
		
		ConnectionConfiguration config = new ConnectionConfiguration(gcmServer, Integer.parseInt(gcmServerPort));
		config.setSecurityMode(SecurityMode.enabled);
		config.setReconnectionAllowed(true);
		config.setRosterLoadedAtLogin(false);
		config.setSendPresence(false);
		config.setSocketFactory(SSLSocketFactory.getDefault());

		// NOTE: Set to true to launch a window with information about packets
		// sent and received
		config.setDebuggerEnabled(true);

		XMPPConnection connection = new XMPPTCPConnection(config);
		connection.addConnectionListener(new GcmConnectionListener());
		connection.addPacketListener(new GcmPacketListener(), new PacketTypeFilter(Message.class));
		connection.addPacketInterceptor(new GcmPacketInterceptor(), new PacketTypeFilter(Message.class));
		
		this.connection = connection;
	}
	
	/**
	 * Returns a random message id to uniquely identify a message.
	 * 
	 * <p>
	 * Note: This is generated by a pseudo random number generator for illustration purpose, and is not guaranteed to be unique.
	 * 
	 */
	public String getRandomMessageId() {
		if(random == null) {
			random = new Random();
		}
		
		return "m-" + Long.toString(random.nextLong());
	}

	/**
	 * Sends a downstream GCM message.
	 * @throws XMPPException 
	 * @throws IOException 
	 * @throws SmackException 
	 */
	private void send(String jsonRequest) throws SmackException, IOException, XMPPException {
		
		Packet request = new GcmPacketExtension(jsonRequest).toPacket();
		connection.sendPacket(request);
	}

	private String createJsonMessage(String to, String messageId, Map<String, String> payload, String collapseKey, Long timeToLive, Boolean delayWhileIdle) {
		Map<String, Object> message = new HashMap<String, Object>();
		message.put("to", to);
		if (collapseKey != null) {
			message.put("collapse_key", collapseKey);
		}
		if (timeToLive != null) {
			message.put("time_to_live", timeToLive);
		}
		if (delayWhileIdle != null && delayWhileIdle) {
			message.put("delay_while_idle", true);
		}
		message.put("message_id", messageId);
		message.put("data", payload);
		return JSONValue.toJSONString(message);
	}
	
	/**
	 * Sends a JSON encoded GCM message.
	 * 
	 * @param to
	 *            RegistrationId of the target device (Required).
	 * @param messageId
	 *            Unique messageId for which CCS will send an "ack/nack" (Required).
	 * @param payload
	 *            Message content intended for the application. (Optional).
	 * @param collapseKey
	 *            GCM collapse_key parameter (Optional).
	 * @param timeToLive
	 *            GCM time_to_live parameter (Optional).
	 * @param delayWhileIdle
	 *            GCM delay_while_idle parameter (Optional).
	 */
	public void sendJsonMessage(String to, Map<String, String> payload, String collapseKey, Long timeToLive, Boolean delayWhileIdle) {
		String message = createJsonMessage(to, getRandomMessageId(), payload, collapseKey, timeToLive, delayWhileIdle);
		try {
			send(message);
		} catch (SmackException | IOException | XMPPException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}


	private String createJsonAck(String to, String messageId) {
		Map<String, Object> message = new HashMap<String, Object>();
		message.put("message_type", "ack");
		message.put("to", to);
		message.put("message_id", messageId);
		return JSONValue.toJSONString(message);
	}
	
	/**
	 * Sends a JSON encoded ACK message for an upstream message received from an application.
	 * 
	 * @param to
	 *            RegistrationId of the device who sent the upstream message.
	 * @param messageId
	 *            messageId of the upstream message to be acknowledged to CCS.
	 */
	public void sendJsonAck(String to, String messageId) {
		String ack = createJsonAck(to, messageId);
		try {
			send(ack);
		} catch (SmackException | IOException | XMPPException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
